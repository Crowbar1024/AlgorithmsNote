所以对于第三方库，我的原则是学习第一使用第二。比如说有一天我们要做一个实时排名的服务，得知redis能做到。于是就去看redis的源码，知道其用的是一个叫做跳表的数据结构。然后我们也用跳表，实现了一个200行左右的实时排名组件。对于这样一个功能，比起直接采用几万行的redis，自己来实现肯定要更好。


排行榜的话，treap比跳表更简单啊，redis的跳表不够独立，参考起来还是很麻烦的


B-Tree 其实就是给 HDD 发明的。


关于用一个结构存储大量数据
这种情况是做一个生成器，itertools，pandas 之类的都是这么干的，然后每次操作是从生成器里取出下一个


思考
BFS常用于迷宫，需要

单次dijkstra无法解决边权的问题，因为其和难以初始化

// 由于没有边的约束，只给了点的信息，即涉及到走来走去，bfs更好，并且可以在一个循环中得到一个联通图的节点数量

// 并且为了不建立visit，使用消元法，而消元的前提就是没有边

输入一个域名，处理这个请求的服务器组有多台服务器，通过哈希负载均衡，

宽度优先，一般需要一个set来统计队列中的是否有重复的

如果程序写复杂了，那就是写错了。

为什么快排的最差情况是On^2，最好是nlogn

用主定理去回答

输入的都是整数（可以理解成都是uint32），在这个前提下能不能做到比快速排序时间复杂度更快（能不能比O（NlogN）更快）？


比如定义局部最小，一个数同时比他左右都小就是局部最小，首尾只要比一个。求一个个数组中的任意一个局部最小的位置，数组元素唯一。如果0和n-1都不是局部最小，那么说明1和n-2都比它俩小，所以局部最小一定在[1,n-2]。取中值m，如果m-1比m小，那么[1,m-1]必有局部最小，同理m+1。

边统计边更新

27

滑动窗口只能解决正数




问答
设计一个针对全球的，访问量极大的id生成系统，必须保证用户每次从该系统得到的ID是唯一的，而且在概率上毫无碰撞可能。
比如我要从成都服务器拿我的ID，成都服务器1s需要十万的ID，那么中国服务器可能一天前给了成都服务器一个startID和range。 成都服务器的ID库就是[startID,startID+range]，这个range给了保证。


贪心和DP的区别
DP中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的，
但有时候贪心就是DP的状态压缩方法

只求一次组合不如DP