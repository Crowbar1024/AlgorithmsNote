# 位运算
## 基本定义
- 原码：最高位是符号。不用的理由：两个正数相减，第二个变负数再相加，其符号位取1，相加后和的符号位还是1，显然是错的。8位范围[-127,127]
- 反码：负数的反码是符号位不变，剩下取反。所以0有两种表示，符号位是0/1的两种情况。8位范围[-127,127]
- 补码：负数的补码是其反码+1。这样负数可以表示更高的值，比如8位可以表示最小的数为-128，即原来反码-0，然而，这样的结果是最小的数没有8位所对应的原码和反码，所以对这个最小值的操作要小心。8位范围[-128,127]

## 基本操作
左右儿子都不存在返回true，一个存在一个不存在返回false，不处理都存在的情况
```c++
if (!l || !r) return l == r;
```
交换：原理是异或运算x\^x\^y=y
也可以用于仅有两个值的数的翻转
```C++
a ^= b;
b ^= a;
a ^= b;
x = a^b^x;  // if(x==a) x=b; else x=a; 
```

判断是否同号，避免溢出
```C++
(a^b) > 0
```

判断奇偶
```C++
x & 1
```

获得x的二进制最后一个1所对应的数
40的补码：  0010 1000
-40的补码：1101 1000
相与之后除最后一个1，都为0
```C++
x = a & (-a)
```

判断x是否是2的幂
显然有1000 & 0111 == 0
如果是4呢？4的幂为
0100 
0001 0000
0100 0000
发现1出现在除1之外的奇数位上，而0x5 = 0101，与5做与运算，删掉了偶数位上的1，所以只要判断最后是否为1
同理可以判断x是否是8的幂
0x8 = 1000，所以8的幂永远出现在1000，即四位中最左边的1
```C++
(x & (x - 1)) == 0  // 2 注意优先级
x & 0x55555555  // 在判断是2的幂之后，判断4
x & 0x88888888  // 在判断是2的幂之后，判断8
```
令x的第m位为1或0
```C++
(1 << (m-1)) | x  // 1
(~(1 << (m-1))) & x  // 0
```

需要无穷大+无穷大不会溢出
```C++
0x3f3f3f3f
memset(a,0x3f,sizeof(a));  // 让数组每个元素都是无穷大
```

只有 < 这个operator怎么知道两个对象是否相等？
```C++
!(a<b) && !(b<a)
```

### 数x中1的个数
类似的题目有：
最简单的方法：根据判断是否是2的幂的方法，不断删掉x最后一位是1的数
```C++
int cnt = 0;
while (x) { 
    x &= x-1; 
    ++cnt; 
}
```
或者用空间换时间
```C++
int lookup_popcnt(uint32_t n) {
#if 0  // generate the table algorithmically, and you should put it outside.
    static uint8_t table[256] = {0};
    for(uint32_t i = 1; i < 256; ++i)
        table[i] = table[i>>1] + i & 1U;
    
    const uint8_t* p = reinterpret_cast<const uint8_t*>(&n);
    return table[p[0]] + table[p[1]] + table[p[2]] + table[p[3]];
#else
# define BIT2(n)       n,       n+1,       n+1,       n+2
# define BIT4(n) BIT2(n), BIT2(n+1), BIT2(n+1), BIT2(n+2)
# define BIT6(n) BIT4(n), BIT4(n+1), BIT4(n+1), BIT4(n+2)
# define BIT8(n) BIT6(n), BIT6(n+1), BIT6(n+1), BIT6(n+2)

    static const uint8_t table[256] = {BIT8(0)};
    return table[n & 0xFF] + table[(n>>8) & 0xFF] +
           table[(n>>16) & 0xFF] + table[(n>>24) & 0xFF];
#endif          
}
// 32位的数数1，从return那里可以看出，就是每8位数一次，那么显然table[x]存的是[0,255]（2^8=256）
// 有1的个数。举个例子：table[0]=0 table[1]=1 table[2]=1 table[3]=2
// 可以发现规律为 table[x]=table[x>>1]+x&1
// 这个就可以写成宏递归的形式，很厉害，翻译一下
// [0,3]是[00,01,10,11]个数为{0,1,1,2}
// [4,7]是[100,101,110,111]个数为[0,3]+1
// [8,11]是[1000,1001,1010,1011]个数为[0,3]+1
// [12,15]是[1100,1101,1110,1111]个数为[0,3]+2
// 同理[16,31]是[0,15]+1
```


### RoundUp
常出现在内存管理中，比如让bytes调整到8的倍数
x是[8n,8n+7]的某个数，让取其roundup到最小的8的倍数，显然除了8n这个数之外都要跑到下个区间，所以+7能保证。
然后就需要舍弃后面的3个1，所以要与上11111000
```C++
static size_t ROUND_UP(size_t bytes) {
  return (((bytes) + __ALIGN-1) & ~(__ALIGN - 1));
}
```





### Ｃ++ 为什么要默认采用 < 来作为std::sort()和其他与排序相关的函数的比较符号呢?

因为<满足strict weak ordering，即能够表达其他所有的逻辑运算符：
| 逻辑运算符 | < |
| :-: | :-: |
| <= | !(b < a) |
| == | !(a < b) && !(b < a) |
| != | (a < b) \|\| (b < a) |
