# 使用函数

### 反转
```C++
reverse(v.begin(),v.end());
```

### 降序排序
```c++
sort(v.rbegin(), v.rend());
```

### 获取极值和得到下标
```C++
auto it = max_element(dp.begin(), dp.end());  // 返回的是迭代器，同理min_element
int maxW = *it;
int maxV = distance(dp.begin(), it);  // 相当于it-v.begin()
return vector<int>{maxV, maxW};
```

### 累加
```C++
int sum = accumulate(nums.begin(), nums.end(), 0);
string str = accumulate(v.begin(), v.end(), "");
```

### 填充
```C++
fill(nums.end()-cnt, nums.end(), 0);
```

### 去重
```C++
sort(a.begin(), a.end());
a.erase(unique(a.begin(), a.end()), a.end());
```

### 获取一段连续的相等元素
```C++
// pair<vector<int>::iterator,vector<int>::iterator>
auto bounds = equal_range(v.begin(), v.end(), 20, mygreater)
cout << bounds.first - v.begin();    // second too
```


lower_bound、upper_bound，大于等于，大于
找不到返回.end()。在字符串里面是按照字典序

set_intersection




### 统计次数
```C++
count(v.begin(), v.end(), value);
```

### 替换
新值（右）换旧值（左），并返回旧值。\<atomic\> 确保并发的安全

```C++
// 第一种，线程不安全
int tmp = dp1;
dp1 = dp1 + dp2;
dp2 = tmp;

// 线程安全
dp2 = exchange(dp1, dp1+dp2);
```

### 删除
remove()和remove_if() 函数会返回移除目标成员之后的区间的尾后迭代器。
```C++
auto itor = remove(str.begin(), str.end(), 'e');  // ::isspace空格
str.erase(itor, str.end());
```

### 寻找
```C++
// v = {2,5,10,20}
auto itor = find(v.begin(), v.end(), 10);
if (itor != v.end()) {...}  // 找不到
cout << *itor  // 找得到
int idx = distance(v.begin(), itor);  // 位置
```




# 设计效率
### 两段设计分配内存的代码

```c++
ListNode* func1(ListNode* head) {
    ListNode dummy(INT_MIN), *tail = &dummy;
    tail->next = head;
    ...  // 对tail和head的操作
    return dummy.next;
}
ListNode* func2(ListNode* root) {
    ListNode *head = new ListNode(0), *cur = head;
    cur->next = head;
    ....  // 对cur和head的操作
    return head->next;
}
```
func2的内存一共分配了3份，一个listnode节点（堆区），一个指向它的指针，以及它的复制。

func1的内存一共分配了2份，一个变量（栈区），指向它的指针。