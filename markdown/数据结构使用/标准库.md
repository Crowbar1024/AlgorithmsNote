# bitset

```c++
// 初始化，下标 0123   
bitset<4> b1 = 8;  // 0001
bitset<4> b2{0xA};  // 0101
bitset<4> b3("0011");  // 1100  string是逆序
bitset<10> v2(v1);
bitset<10> v3 = v2;
// 一个重要的性质，支持所有位运算
// b1&b2 = 0001
 
// bitsets can be printed out to a stream，就是string的逆序
cout << b1;  // 1000

.any()  // 如果有位被设置为1返回真，否则返回假。
.count()  // 返回bitset中被设置成1的位的个数。
.flip()  // 反置bitset中所有的位，即将1设为0，0设为1。
.flip(pos)如果指定pos，那么只有pos上的位被反置。
.none()  // 如果没有位被设为1返回真，否则返回假。
```

# pair

```c++
// 初始化
pair<int,int> p(p1, p2);
pair<int,int> pt(p1, p2);

// 返回临时对象
return pair<int,int>{p1, p2};
return {p1, p2};

// 可以直接比较，是值比较
p == pt

// 取值
p.first
p.second

// 放入容器
queue<pair<int,int>> q;
q.push(pair<int,int>(p1, p2));
q.push(make_pair(p1, p2));
q.push({p1, p2});  // 简单的写法

// 遍历
vector<pair<int, int>>jobs(n);
for (int i=0; i<n; ++i) {
    jobs[i] = make_pair(difficulty[i], profit[i]);
}

```
